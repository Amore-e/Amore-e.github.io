{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2020/09/17/computer-science/algorithm/hello-world/",
            "url": "http://example.com/2020/09/17/computer-science/algorithm/hello-world/",
            "title": "Hello World",
            "date_published": "2020-09-17T02:27:39.910Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2020/09/17/computer-science/algorithm/%E6%8E%92%E5%BA%8F/",
            "url": "http://example.com/2020/09/17/computer-science/algorithm/%E6%8E%92%E5%BA%8F/",
            "title": "",
            "date_published": "2020-09-17T02:27:39.867Z",
            "content_html": "<h1 id=\"排序\"><a class=\"markdownIt-Anchor\" href=\"#排序\">#</a> 排序</h1>\n<p>排序算法是数据结构中最基本的算法之一。</p>\n<p>排序算法可以分为<strong>内部排序和外部排序。</strong></p>\n<p>内部排序是数据记录在内存中进行排序。二外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>\n<p><img data-src=\"F:%5CPictures%5C%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%5C1342514529_5795.jpg\" alt=\"\"></p>\n<p><img data-src=\"https://pic1.zhimg.com/80/v2-f50f588e8c546bb649b78f8ccc20689c_720w.jpg\" alt=\"img\"></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20181108191001927.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rjcm1n,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<p>时间复杂度 **</p>\n<ol>\n<li>平方阶 (O (n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li>\n<li>线性对数阶 (O (nlog2n)) 排序 快速排序、堆排序和归并排序；</li>\n<li>O (n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li>\n<li>线性阶 (O (n)) 排序 基数排序，此外还有桶、箱排序。</li>\n</ol>\n<p><strong>稳定性</strong></p>\n<ol>\n<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</li>\n<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li>\n</ol>\n<p><strong>冒泡排序</strong></p>\n<ul>\n<li>思想：冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</li>\n<li>动画演示：</li>\n</ul>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2019030515082371.gif\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BubbleSort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; (<span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>]))<span class=\"number\">-1</span> ;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j &lt; (<span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>])) <span class=\"number\">-1</span>- i;j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j]&gt;arr[j+<span class=\"number\">1</span>]) &#123;<span class=\"comment\">//相邻元素比较</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">int</span> tepm = arr[j];<span class=\"comment\">// 两两交换</span></span><br><span class=\"line\">\t\t\t\tarr[j] = arr[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t\tarr[j + <span class=\"number\">1</span>] = tepm;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>选择排序</strong></p>\n<ul>\n<li>\n<p>思想： 选择排序是每一次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</p>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2019030515170010.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SelectSort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt;(<span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>])) <span class=\"number\">-1</span>;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> k = arr[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i;j &lt; (<span class=\"keyword\">sizeof</span>(arr)/<span class=\"keyword\">sizeof</span>(arr[<span class=\"number\">0</span>])) - <span class=\"number\">1</span>;j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j] &lt; k) &#123; <span class=\"comment\">//寻找最小的数</span></span><br><span class=\"line\">\t\t\t\tk = arr[j]; </span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (k &lt; arr[i]) </span><br><span class=\"line\">\t\t\tarr[i] = k;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>插入排序</strong></p>\n<ul>\n<li>思想：它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O (1) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>\n<li>动画演示：</li>\n</ul>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305152332174.gif\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>希尔排序</strong></p>\n<ul>\n<li>\n<p>思想：希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破 O (n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>\n<p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。<br>\n<img data-src=\"https://img-blog.csdnimg.cn/20190305152953904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01MY29uZ2NvbmdBSQ==,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305153045812.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>归并排序</strong></p>\n<ul>\n<li>\n<p>思想：该算法是采用<strong>分治法</strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305154824659.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>快速排序</strong></p>\n<ul>\n<li>\n<p>思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<p>快速排序使用<strong>分治法</strong>来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<p>从数列中挑出一个元素，称为 “基准”（pivot），即枢纽元；</p>\n<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边），在这个分区退出之后，该基准就处于数列的中间位置，称为分区（partition）操作；</p>\n<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305155529277.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>堆排序</strong></p>\n<ul>\n<li>\n<p>思想：堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>\n源于优先级序列：第一阶段，add 操作整体时间复杂度为 O (nlog n)；若第一阶段采用自底而上构建堆，时间复杂度为 O (n)；第二阶段 remove_min 操作整体时间复杂度为 O (nlog n)，总体时间复杂度为 O (nlog n)</p>\n</li>\n<li>\n<p>将初始待排序关键字序列 (R1,R2….Rn) 构建成大顶堆，此堆为初始的无序区；</p>\n<p>将堆顶元素 R [1] 与最后一个元素 R [n] 交换，此时得到新的无序区 (R1,R2,……Rn-1) 和新的有序区 (Rn), 且满足 R [1,2…n-1]&lt;=R [n]；</p>\n<p>由于交换后新的堆顶 R [1] 可能违反堆的性质，因此需要对当前无序区 (R1,R2,……Rn-1) 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2….Rn-2) 和新的有序区 (Rn-1,Rn)。</p>\n<p>不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</p>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305160256402.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>计数排序</strong></p>\n<ul>\n<li>\n<p>思想：计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>\n<p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p>\n<ol>\n<li>找出待排序的数组中最大和最小的元素；</li>\n<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>\n<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>\n<li>反向填充目标数组：将每个元素 i 放在新数组的第 C (i) 项，每放一个元素就将 C (i) 减去 1</li>\n</ol>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305161505758.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>桶排序</strong></p>\n<ul>\n<li>\n<p>思想：桶排序 (Bucket sort) 是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>\n<p>工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序。</p>\n<p>设置一个 BucketSize，作为每个桶所能放置多少个不同数值</p>\n<p>设置一个定量的数组当作空桶；<br>\n遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>\n对每个不是空的桶进行排序；<br>\n从不是空的桶里把排好序的数据拼接起来。<br>\n注意，如果递归使用桶排序为各个桶排序，则当桶数量为 1 时要手动减小 BucketSize 增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</p>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305163056336.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>基数排序</strong></p>\n<ul>\n<li>\n<p>思想：基数排序也是非比较的排序算法，又称卡片排序；</p>\n<p>对每一位进行排序，从最低位开始排序，复杂度为 O (kn), n 为数组长度，k 为数组中的数的最大的位数；</p>\n<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p>\n<p>有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>\n<p>基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<p>取得数组中的最大数，并取得位数；<br>\narr 为原始数组，从最低位开始取每个位组成 radix 数组；<br>\n对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；<br>\nMSD ：从高位开始进行排序<br>\n LSD ：从低位开始进行排序</p>\n<p>对桶的使用方法上有明显<strong>差异</strong>：</p>\n<ul>\n<li>基数排序：根据键值的每位数字来分配桶</li>\n<li>计数排序：每个桶只存储单一键值</li>\n<li>桶排序：每个桶存储一定范围的数值</li>\n</ul>\n</li>\n<li>\n<p>动画演示：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190305163804867.gif\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li>\n<p>代码实现：</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01MY29uZ2NvbmdBSS9hcnRpY2xlL2RldGFpbHMvODgwODEyNDQ=\">参考文献</span></p>\n",
            "tags": []
        }
    ]
}